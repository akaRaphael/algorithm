# 1) Union-Find 알고리즘이란?
# - 크루스칼 알고리즘에서 사이클 유무를 검증하기위해 사용하는 알고리즘
# - Disjoint Set을 표현하기위해 사용하는 알고리즘

# 1-1) Disjoint Set이란? 
# - 서로 중복되지 않는 부분집합의 요소(= 노드) 정보를 관리하는 자료구조
# - 공통원소가 없는 부분집합들의 모임을 Disjoint Set(서로소 집합)라고 한다. 

# 2) Union-Find 동작과정
# a. 개별화 
#    - 그래프의 각 노드를 개별집합으로 초기화한다.

# b. Union(합집합) 생성 
#    - 2개의 개별집합을 하나의 집합으로 합치는 과정
#    - 2개의 트리를 하나의 트리로 합치는 과정  

# c. Find(검증) 
#    - 사이클을 검증하는 단계로, 각 부분집합의 루트노드를 확인한다.
#    - 루트노드가 다르면 서로소 상태(= 사이클 없음)로 판단한다.

# 3) Union-Find 로직 이해 

def find(node):
  if node == parent[node]: # 부분집합의 원소 == 루트노드 
    return node
  else:
    root = find(parent[node]) # 재귀적 접근으로 상위 노드를 타고 루트노드를 찾는 과정 
    parent[node] = root
    return parent[node]

def union(node1, node2):
  node1 = find(node1) # 노드1의 부모노드를 찾음 
  node2 = find(node2) # 노드2의 부모노드를 찾음 
  parent[node2] = node1 # 노드1과 노드2의 부모노드 중 상위 노드를 부모노드로 대체시킨다.
  
  
# 4) 주의사항
# - Union 과정에서 어떤 루트노드에 어떤 부분집합이 어떻게 연결되는지 알 수 없다.
# - 그러므로 최악의 경우, left/right skewed tree(= 연결리스트)의 형태를 가질 수 있다.
# - 이 경우 Union-Find의 시간복잡도는 O(n)이 된다. 매번, 모든 노드를 거쳐 루트노드를 찾기 때문이다.
# - 이 문제를 해결하기 위해 Union-By-Rank 또는 Path compression 기법을 사용한다. 

# 4-1) Union-By-Rank 기법 
# - 최초에 신장트리의 각 노드를 개별 집합화 하는 과정에서 Rank(=높이)를 0으로 설정한다. 
# - 이후 Union 과정에서 두개의 트리를 합칠때, Rank가 더 높은 트리를 루트노드로 설정한다.
# - 동일한 Rank를 가진 서로다른 부분집합을 Union 할 때에는 한쪽 부분집합의 Rank를 1 증가시켜 임의로 루트노드를 지정한다.
# - 이 기법을 사용하여 Union을 실행하면 한쪽으로 치우쳐진 트리의 생성을 예방할 수 있다.
# - Union-By-Rank 기법으로 사용하면 O(log n)의 시간복잡도의 트리를 생성한다.

# 4-2) Path Compression 기법 
# - 루트노드를 찾은 후, 루트노드의 모든 자식노드를 동일한 레벨의 형제노드로 위치변경 하는 기법
# - 이 기법을 사용하면 O(M log* N)의 시간복잡도를 갖는다.

# 4-3) 결론 
# - Union-By-Rank와 Path Compression 기법을 사용하면 O(1)의 시간복잡도를 갖는다는 결론이 나온다.
# - 두 기법 모두, N이 무한대에 가까운 값을 가지더라도 log N으로 계산하면 상수에 가까운 값이 나오기 때문이다.  