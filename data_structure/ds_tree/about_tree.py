# 1) Tree란?
# - Tree는 노드와 브랜치를 이용하여 구현된, 사이클이 없는 자료구조다.
# - Tree는 이진트리의 형태로 구현되어 탐색 알고리즘 구현에 사용된다. 

# 2) Binary Tree(이진트리)란?
# - 자식노드가 최대 2개로 이루어진 트리 
# - 좌/우측 자식노드 각 1개씩, 최대 2개의 자식노드를 가질 수 있다. 
# - 이진탐색(=검색)트리의 형태로 탐색을 위해 자주 사용된다. 

# 3) Binary Search Tree란?
# - 왼쪽노드가 반드시 오른쪽 노드보다 작은 값을 유지하는 형태의 트리를 말한다.
# - 부모노드를 기준으로 왼쪽에는 부모보다 작은 값이, 오른쪽에는 부모보다 큰 값이 정렬된다.

# 4) Binary Search Tree의 장점
#  - 검색에 용이하다. 한번 분류될 때마다 탐색해야하는 데이터의 수가 50%씩 줄어들기 때문이다.
#  - 즉, O(log n) 의 시간복잡도를 갖게된다. 

# 5) Binary Search Tree의 단점
# - 구현이 복잡하다. 
# - 자료가 많아질수록 트리의 level이 높아지고, 이로인해 검색시간이 최대(worst) log n이 될 수 있다.
# - 탐색에는 용이하지만, 삽입/삭제에는 용이하지 않다. 재정렬이 필요하기 때문이다. 

# 6) Tree의 종류 
# a. Full binary Tree(정이진트리)
#   - 모든 노드가 0개 또는 2개의 자식노드를 가지고 있는 이진트리 

# b. Perfect Binary Tree(포화이진트리)
#   - 모든 부모노드가 2개의 자식노드를 가지고 있는 이진트리 
#   - 모든 단말노드(leaf)가 동일한 level을 가진 이진트리 

# c. Complete Binary Tree(완전이진트리)
#   - 마지막 level 이전까지 모든 노드가 채워진 이진트리 
#   - 마지막 level의 단말노드(leaf)는 왼쪽 노드부터 채워지는 이진트리
#   - 탐색/검색에 최적화 되어있는 자료구조  
#   - Heap 자료구조가 완전이진트리를 이용해 작성된 Binary Heap이다.

# d. Degenerate or Pathological Tree(변질트리)
#   - 모든 노드가 1개의 자식노드만을 가진 트리
#   - 연결리스트와 성능은 동일하다. 

# e. Balanced Binary Tree(균형이진트리, AVL트리)
#   - 이진탐색트리의 단점을 보완한 이진트리 
#   - 좌/우측 sub tree의 높이차이가 최대 1이하를 유지하는 이진트리 (기하급수적으로 level이 높아지는 것을 방지함)
#   - 좌/우측 sub tree의 높이차이를 균형인수(Balance Factor) 라고 부르며 -1, 0, 1 중 하나의 값을 가진다.
#   - 트리의 데이터 삽입/삭제가 발생하는 경우 Balance Factor를 이용하여 재정렬한다.
#   - 좌/우측 sub tree 간의 level 차이가 1이하이므로, 탐색/삽입/삭제 모두 최대 O(log 2n)이 걸린다.
#   - 균형이진트리의 경우, 자료가 많아질수록 재정렬 하는데 걸리는 시간이 증가한다는 단점이 있다.

# 7) Tree Traverse(순회)
#           1 
#       2      3
#    4    5    
#   a. Pre-order Traverse(전위순회, DFS - 깊이우선탐색)
#     - root노드를 기준으로 왼쪽 자식노드를 모두 방문 
#     - 가장 좌측의 말단노드를 기준으로 우측노드를 하나씩 방문 
#     - 순회결과: 1 => 2 => 4 => 5 => 3 

#   b. In-order Traverse(중위순회, 대칭탐색)
#     - 가장 좌측의 말단노드를 기준으로, 
#       좌측 자식노드 -> 부모노드 -> 우측 자식노드 순으로 방문 
#     - 순회결과: 4 => 2 => 5 => 1 => 3

#   c. Post-order Traverse(후위순회)
#     - root노드를 기준으로 좌측 sub tree -> 우측 sub tree 순으로 방문 
#     - 순회결과: 4 => 5 => 2 => 3 => 1

#   d. Level-order Traverse(층별순위, BFS)
#     - root노드를 기준으로 동일한 level에 위치한 노드를 좌측부터 순차적으로 방문
#     - 순회결과: 1 => 2 => 3 => 4 => 5 